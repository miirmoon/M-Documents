# 1. 상황에 따라 달라지는 this

<aside>
✔️ **this** ⇒ 실행 컨텍스트가 생성될 때 결정 → **실행 컨텍스트**(this binding component) ****⇒ 함수를 호출할 때 생성

</aside>

- 자바스크립트에서의 this는 다른 언어와 다르게 상황에 따라 가리키는 대상이 다르다.
- 명시적 this 바인딩이 없는 한 다음과 같은 규칙을 따른다.
    <aside>
    🐥 **전역 공간**에서의 this는 **전역 객체를 참조**한다.
    
    </aside>
    
    - 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global이라는 이름을 가진다.
    - 전역변수를 선언(var)하면 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당한다. 그런데 이는 var로 선언한 변수에만 해당된다.
    - let, const로 선언한 변수의 경우 전역 객체의 프로퍼티로 할당되지 않는다.
    - var로 선언한 경우에도 useStrict(엄격 모드)인 경우에는 전역 객체를 참조하지 않는데, 이는 보안을 위해 window 객체에 직접 접근하지 못하도록 하기 위함이라고 한다.
    - ES6에서 let, const를 새로 만들면서 이를 반영한 것이 아닐까 생각된다.
    - 또한, let, const는 var(함수 레벨 스코프)와 달리 블록 레벨 스코프로 동작한다. 특정한 블록 내에서만 동작하기 때문에 전역 객체를 참조하지 않도록 하는 것으로 보인다.
        - let, const를 전역으로 선언하면 보이지 않는 자체 블록을 생성하여 그 안에서 동작한다.
    
    <aside>
    🐥 어떤 함수를 **메서드로서 호출한 경우** this는 **메서드 호출 주체를 참조**한다.
    
    </aside>
    
    - 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행하는 함수를 말한다.
    - 다른 언어와 달리 자바스크립트에서는 어떤 함수를 객체의 프로퍼티에 할당하는 것 만으로 메서드가 되지는 않는다.
    - 호출을 어떻게 하느냐에 따라 메서드 또는 일반 함수로 동작한다.
    - 어떤 함수를 호출할 때 함수 이름 앞에 객체가 명시되어 있으면(점 또는 대괄호 표기법) 메서드로 호출한 것이고, 그렇지 않으면 일반 함수로 호출한 것이다.
    
    <aside>
    🐥 어떤 함수를 **함수로서 호출한 경우** this는 **전역 객체를 참조**한다.
    
    </aside>
    
    - 메서드가 아닌 함수로서 호출하는 함수(단독으로 호출)는 호출 주체가 명시되어있지 않기 때문에 따로 this가 지정되지 않는다.
    - 메서드 내부에서 호출하는 함수도 동일하게 동작한다.
    - 다른 언어처럼 this가 알아서 가까운 환경의 정보를 바인딩 할 수는 없을까? 언어의 고유한 특성이기 때문에 없다. 하지만 우회할 수 있는 방법은 있다.
        
        ⇒ 그것은 바로 상위 스코프의 this를 변수에 저장하는 방법, 보통 self라는 변수명을 이용한다.
        
    - 이를 보완하기 위해 ES6에서 도입된 것이 **화살표 함수**이다.
        - 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정이 없다.
        - 이 함수 내부에서 this에 접근하려고 하면 스코프체인상 가장 가까운 this에 접근한다.
    
    <aside>
    🐥 **콜백 함수 내부**에서의 this는 **제어권을 넘겨받은 함수가 정의한 바에 따르며**, 정의하지 않은 경우 전역객체를 참조한다.
    
    </aside>
    
    <aside>
    🐥 **생성자 함수**(new 키워드를 붙여 호출)에서의 this는 **생성될 인스턴스를 참조**한다.
    
    </aside>

# 2. 명시적으로 this 바인딩하기

- 명시적으로 this를 바인딩하기 위한 메서드로 call, apply, bind가 있다.

```javascript
Function.prototype.**call**(thisArg[, arg1[, arg2[, ...]]])
Function.prototype.**apply**(thisArg[, argsArray])
Function.prototype.**bind**(thisArg[, arg1[, arg2[, ...]]])
```

### 1) call, apply 메서드

- call과 apply는 this를 명시적으로 지정하면서 함수 또는 메서드를 즉시 실행하도록 하는 명령어이다.
- 함수를 그냥 실행하면 this는 전역 객체를 참조하지만 call, apply 메서드를 이용하면 임의의 객체를 this로 지정할 수 있다.
- call과 apply는 기능적으로 완전히 동일하고, apply는 두 번째 인자를 배열로 받는다는 점만 다르다.
- 생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call 또는 apply를 이용해 다른 생성자를 호출하면 반복을 줄일 수 있다.
- call/apply 메서드는 명시적으로 별도의 this를 바인딩하면서 함수 또는 메서드를 실행하는 좋은 방법이지만 이로 인해 this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있다.
  - ES5 이하의 환경에서는 더 좋은 대안이 없기 때문에 광범위하게 사용된다.
  - ES6에서는 더 좋은 대안이 있다는 뜻이겠지? ⇒ 화살표 함수!!

### 2) bind 메서드

- call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환한다.
- 다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 bind 메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록된다.
- name 프로퍼티에 bound라는 접두어가 붙기 때문에 코드를 추척하기에 보다 수월하다.

```javascript
var func = function (a, b, c, d) {
  console.log(this, a, b, c, d);
};
func(1, 2, 3, 4); // Window {...} 1 2 3 4

var bindFunc1 = func.bind({ x: 1 });
bindFunc1(5, 6, 7, 8); // { x: 1 } 5 6 7 8

var bindFunc2 = func.bind({ x: 1 }, 4, 5); // 부분 적용
bindFunc2(6, 7); // { x: 1 } 4 5 6 7
bindFunc2(8, 9); // { x: 1 } 4 5 8 9
```

## 💡 별도의 인자를 this로 받는 경우

- 콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인자로 지정할 수 있는 경우가 있다.
- 이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this 값을 원하는 대로 변경할 수 있다.
- thisArg로 아무것도 넘기지 않을 경우 undefined를 넘겨주며, 이 때 this는 위에서 본 규칙에 따라 대상이 결정된다.

🤗 참고

- 코어자바스트립트 / 정재남
- [MDN - forEach()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
